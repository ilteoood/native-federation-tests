var v=Object.defineProperty;var c=Object.getOwnPropertySymbols;var x=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var p=(t,e,o)=>e in t?v(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,i=(t,e)=>{for(var o in e||(e={}))x.call(e,o)&&p(t,o,e[o]);if(c)for(var o of c(e))h.call(e,o)&&p(t,o,e[o]);return t};import U from"chalk";import{rm as A}from"fs/promises";import{resolve as z}from"path";import{mergeDeepRight as B,mergeRight as N}from"rambda";import{build as Z}from"tsup";import{createUnplugin as w}from"unplugin";var y={testsFolder:"@mf-tests",mocksFolder:"./__mocks__",deleteTestsFolder:!0},T=(t,e)=>{let o=e.split("@").at(-1),r=new URL(o);return r.pathname=`${t.testsFolder}.zip`,r.href},C=t=>Object.entries(t.moduleFederationConfig.remotes).reduce((e,[o,r])=>(e[o]=T(t,r),e),{}),a=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e=i(i({},y),t),o=C(e);return{hostOptions:e,mapRemotesToDownload:o}};import{existsSync as b}from"fs";import{join as m}from"path";var k={testsFolder:"@mf-tests",distFolder:"./dist",deleteTestsFolder:!0,additionalBundlerConfig:{}},H=["ts","tsx","js","jsx","mjs"],l=t=>{let e=process.cwd();for(let o of H){let r=m(e,`${t}.${o}`);if(b(r))return r}},j=t=>Object.entries(t.moduleFederationConfig.exposes).reduce((e,[o,r])=>(e[o]=l(r)||l(m(r,"index"))||r,e),{}),f=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e=i(i({},k),t),o=j(e),r=Object.keys(t.moduleFederationConfig.shared||{}).concat(Object.keys(t.moduleFederationConfig.remotes||{})),s=m(e.distFolder,e.testsFolder);return{remoteOptions:e,externalDeps:r,compiledFilesFolder:s,mapComponentsToExpose:o}};import u from"adm-zip";import E from"axios";import q from"chalk";import{join as g}from"path";var S=t=>g(t.distFolder,`${t.testsFolder}.zip`),F=async(t,e)=>{let o=new u;return await o.addLocalFolderPromise(e,{}),o.writeZipPromise(S(t))},$=(t,e)=>o=>{throw console.error(q.red(`Unable to download federated mocks for '${t}' from '${e}' because '${o.message}', skipping...`)),o},O=t=>async([e,o])=>{let r=await E.get(o,{responseType:"arraybuffer"}).catch($(e,o)),s=g(t.mocksFolder,e);new u(Buffer.from(r.data)).extractAllTo(s,!0)};import{rm as D}from"fs/promises";import{join as P}from"path";var R=async(t,e)=>{let o=e.map(r=>{let s=P(t.mocksFolder,r);return D(s,{recursive:!0,force:!0})});return Promise.allSettled(o)};var fe=w(t=>{let{remoteOptions:e,compiledFilesFolder:o,externalDeps:r,mapComponentsToExpose:s}=f(t);return{name:"native-federation-tests/remote",async writeBundle(){let n=N(e.additionalBundlerConfig,{external:r.map(d=>new RegExp(d)),entry:s,outDir:o});try{await Z(n),await F(e,o),e.deleteTestsFolder&&await A(o,{recursive:!0,force:!0})}catch(d){console.error(U.red(`Unable to build concatenated source files: ${d}`))}},webpack:n=>{n.options.devServer=B(n.options.devServer||{},{static:{directory:z(e.distFolder)}})}}}),ue=w(t=>{let{hostOptions:e,mapRemotesToDownload:o}=a(t);return{name:"native-federation-tests/host",async writeBundle(){e.deleteTestsFolder&&await R(e,Object.keys(o));let r=O(e),s=Object.entries(o).map(r);await Promise.allSettled(s)}}});export{ue as NativeFederationTestsHost,fe as NativeFederationTestsRemote};
